<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>LinearAlgebraWork14</title>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>$(function () {
    sagecell.makeSagecell({inputLocation:'div.linked_sage',linked:true,evalButtonText:'Run Linked Sage Cells'});
    sagecell.makeSagecell({inputLocation:'div.linked_python',linked:true,evalButtonText:'Run Linked Python Cells'});
    sagecell.makeSagecell({inputLocation:'div.linked_r',linked:true,evalButtonText:'Run Linked R Cells'});
    sagecell.makeSagecell({inputLocation:'div.sage',evalButtonText:'Run'});
    sagecell.makeSagecell({inputLocation:'div.sage_html',evalButtonText:'Run HTML'});});
    </script>
  </head>
  <style>
  @import url('https://fonts.googleapis.com/css?family=Orbitron');
  h1, h2 {color:#3636ff; font-family:'Orbitron'; text-shadow:5px 5px 5px #aaa;}
  p, a {color:darkblue; font-size:110%; text-shadow:5px 5px 5px #aaa;}
  .sagecell .CodeMirror-scroll {min-height:3em; max-height:30em;}
  body {margin:5px 5px 5px 25px;}
  </style>  
  <body>
    <h1>&#x1F4D1; &nbsp; GPT Python Notes 01</h1>
    <h1>Variables and Data Types || Variables y tipos de datos</h1>
    <table>
      <tr><th>Basic built-in structures</th><th>Estructuras integradas b√°sicas</th></tr>
      <tr><td>- constants</td><td>- constantes</td></tr>
      <tr><td>- functions</td><td>- funciones</td></tr>
      <tr><td>- data of various types</td><td>- datos de varios tipos</td></tr>
      <tr><td> - - numeric: int, float, complex</td><td> - - num√©rico: int, float, complex</td></tr>
      <tr><td> - - string: str</td><td> - - cadena: str</td></tr>
      <tr><td> - - sequence: list, tuple, range</td><td> - - secuencia: list, tuple, range</td></tr>
      <tr><td> - - binary: bytes, bytearray, memoryview</td><td> - - binario: bytes, bytearray, memoryview</td></tr>
      <tr><td> - - mapping: dict</td><td> - - mapeo: dict</td></tr>
      <tr><td> - - boolean: bool</td><td> - - booleano: bool</td></tr>
      <tr><td> - - set data types: set, frozenset</td><td> - - tipos de conjunto de datos: conjunto, conjunto congelado</td></tr>
      <tr><td> - - NoneType: None</td><td> - - NingunoTipo: None</td></tr>
      <tr><td> - - files: file</td><td> - - archivos: file</td></tr>
      <tr><td>- data of constructed types of built-in modules</td><td> - datos de tipos construidos de m√≥dulos integrados</td></tr>
      <tr><td> - - date and time: datetime, date, time, timedelta </td><td> - - fecha y hora: datetime, date, time, timedelta </td></tr>
      <tr><td> - - regular expression: re.Pattern</td><td> - - expresi√≥n regular: re.Pattern</td></tr>
      <tr><td> - - ...</td><td>- - ...</td></tr>
      <tr><td>- exceptions with error details generated by the interpreter or built-in functions</td>
          <td>- excepciones con detalles de error generados por el int√©rprete o funciones integradas</td></tr>
      <tr><td> ! The type of a variable is only determined at runtime.</td>
          <td> ! El tipo de variable s√≥lo se determina en tiempo de ejecuci√≥n.</td></tr>
    </table><br/>

<div class="linked_sage"><script type="text/x-sage">
import builtins, types
dir(builtins)
[name for name, obj in vars(builtins).items() 
 if isinstance(obj, types.BuiltinFunctionType)]
</script></div><br/><br/><br/> 
    <table>
      <tr><th>Units (tokens) of the Python language</th><th>Unidades (tokens) del lenguaje Python</th></tr>
      <tr><td>- comments</td><td>- comentarios</td></tr>
      <tr><td>- literals</td><td>- literales</td></tr>
      <tr><td>- - special (None)</td><td>- - especial (None)</td></tr>
      <tr><td>- - boolean (True, False)</td><td>- - booleano (True, False)</td></tr>
      <tr><td>- - numerical (integer, real, complex)</td><td>- -num√©rico (entero, real, complejo)</td></tr>
      <tr><td>- - string</td><td>- - cadena</td></tr>
      <tr><td>- - byte literals</td><td>- - literales de bytes</td></tr>
      <tr><td>- literal collections (lists, tuples, sets, immutable sets, dictionaries)</td>
          <td>- colecciones literales (listas, tuplas, conjuntos, conjuntos inmutables, diccionarios)</td></tr>
      <tr><td>- keywords</td><td>- palabras clave</td></tr>
      <tr><td>- non-strict keywords (case, match, _)</td><td>- palabras clave no estrictas (case, match, _)</td></tr>
      <tr><td>- punctuation marks</td><td>- signos de puntuaci√≥n</td></tr>
      <tr><td>- - hash #</td><td>- - hash #</td></tr>
      <tr><td>- - dollar sign $</td><td>- - signo de d√≥lar $</td></tr>
      <tr><td>- - at sign @</td><td>- - signo @</td></tr>
      <tr><td>- - underscore _</td><td>- - guion bajo _</td></tr>
      <tr><td>- operator symbols</td><td>- s√≠mbolos del operadores</td></tr>
      <tr><td>- delimiters</td><td>- delimitadores</td></tr>
      <tr><td>- - parentheses ( )</td><td>- - par√©ntesis ( )</td></tr>
      <tr><td>- - square brackets [ ]</td><td>- - corchetes [ ]</td></tr>
      <tr><td>- - curly braces { }</td><td>- - llaves curvas { }</td></tr>
      <tr><td>- - colon :</td><td>- - colon :</td></tr>
      <tr><td>- - comma ,</td><td>- - coma ,</td></tr>
      <tr><td>- - semicolon ;</td><td>- - punto y coma;</td></tr>
      <tr><td>- - period .</td><td>- - per√≠odo .</td></tr>
      <tr><td>- identifiers</td><td>- identificadores</td></tr>
    </table><br/>
<div class="linked_sage"><script type="text/x-sage">
print(None, True, 10, 10e-3, 1/3, 5j,'—Ç–µ–∫—Å—Ç','ü¶Å')
print(b'\abc', rb'\abc')
print([1,'2',3.], (1,'2',3.), {1,'2',3.},{'1':1,'2':2.})
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
len(rb'\abc'), type(rb'\abc'), len(b'\abc'), type(b'\abc')
</script></div><br/><br/><br/> 
    <table>
      <tr><th>Built-in constants</th><th>Constantes incorporadas</th></tr>
      <tr><td>basic (False, True, None)</td><td>b√°sico (False, True, None)</td></tr>
      <tr><td>special (NotImplemented, Ellipsis, __debug__)</td><td>especial (NotImplemented, Ellipsis, __debug__)</td></tr>
      <tr><td>non-software (quit(), exit(), copyright, credits, license)  </td>
          <td>no software (quit(), exit(), copyright, credits, license)</td></tr>
    </table><br/>
<div class="linked_sage"><script type="text/x-sage">
# special / especial
None, type(1000), type(10e3), type(True), ..., type(...)
</script></div><br/><br/><br/>
Identifiers are user-defined names that represent variables, functions, classes, etc.<br/>
The variable is an identifier, which points to the specific area of memory where the created object is stored.<br/>
Properties:<br/>
- is created at first mention,<br/>
- the value stored in the variable can be accessed or updated later,<br/>
- no announcement required,<br/>
- the data type of the variable is determined automatically and dynamically,<br/>
- the interpreter reserves memory based on the data type of the variables.<br/><br/>
Los identificadores son nombres definidos por el usuario que representan variables, funciones, clases, etc.<br/>
La variable es un identificador que apunta al √°rea espec√≠fica de la memoria donde se almacena el objeto creado.<br/>
Propiedades:<br/>
- se crea en la primera menci√≥n,<br/>
- se puede acceder al valor almacenado en la variable o actualizarlo m√°s tarde,<br/>
- no se requiere anuncio,<br/>
- el tipo de datos de la variable se determina de forma autom√°tica y din√°mica,<br/>
- el int√©rprete reserva memoria en funci√≥n del tipo de datos de las variables.<br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# valid identifier names / nombres de identificadores v√°lidos
myvar = my_var = _my_var = myVar = MYVAR = myvar2 = "name"
# bad ideas for variable names / malas ideas para nombres de variables
# 2myvar = my-var = my var = my.variable = "name"
print(myvar)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# swap variable values / intercambiar valores de variables
x, y = 0, 1
x, y = y, x
print(x, y)
# unpack values / desempaquetar valores
values = [1, 2, 3]
a, b, c = values
print(a, b, c)
# interactive / interactivo
# name = input("Enter your name: ")
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# combine with operations / combinar con operaciones
x = 10
x **= 3
y = x ** (1/3)
z = x > y
print(x, y, z)
exp = "[x * 2 for x in range(5)]"
t = eval(exp)
print(t)
t = tuple(t)
print(t)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# remove part of an object or the entire object
# eliminar parte de un objeto o el objeto completo
a = [1,3,5]
print(a)
del a[0]
print(a)
del a
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# extract useful information / extraer informaci√≥n √∫til
x = 10.5
print(x, x.__int__(), x.as_integer_ratio())
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# difference between global and local variables
# diferencia entre variables globales y locales
x = "perfect"
def myfunc():
# local names don't affect global ones
# los nombres locales no afectan a los globales
     x = "terrible"
     print("the weather now is " + x)
myfunc()
print("the weather now is " + x)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# "Python calculator" interactively
# the last value is assigned to the special variable _
# "Calculadora Python" de forma interactiva
# el √∫ltimo valor se asigna a la variable especial _
tax = 12.5 / 100
price = 100.5
print(_)
price * tax
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
print(_)
price + _
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
print(_)
round(_, 2)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# groups of variables / grupos de variables
for i in range(5): globals()['x%d'%i] = 2**i
print(x0,x2,x4)
for i in range(5): vars()['y%d'%i] = 2**i
print(y0,y2,y4)
for i in range(5): exec(f"m{i} = {2**i}")
print(m0,m2,m4)
eval(compile('for i in range(5): globals()["n%d"%i] = 2**i',
             '', 'exec'))
print(n0,n2,n4)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# global variables h0,h1,... do not exist
# las variables globales h0,h1,... no existen
[exec(f"h{i} = {2**i}; print(h{i}, end=' ')") for i in range(5)];
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
globals()
</script></div><br/><br/><br/>
Constants are special variables with values that cannot be changed.<br/>
Literals are representing fixed values in a program and could be stored into variables with their own properties.<br/><br/>
Las constantes son variables especiales con valores que no se pueden cambiar.<br/>
Los literales representan valores fijos en un programa y podr√≠an almacenarse en variables con sus propias propiedades.<br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# logical / l√≥gico
# constants only / solo constantes
for el in [dir(True)[i:i+6] for i in range(0,72,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
x, y = True, False
True.__hash__(), False.__hash__(), x.real, x.imag, y.real, y.imag
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# the comparison result / el resultado de la comparaci√≥n
3 > 2, 5 < 8, len('abc') == 1, 2 ** 3 >= 9, 11 <= 7, 7 != 12
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# the result of logical and bitwise expressions
# el resultado de expresiones l√≥gicas y bit a bit
logic_exp = [True and False, True or False, 
             True or 0, 1 or False, True and 0, 1 and False,
             not False, not 1] 
for le in logic_exp: print(le, end=' ')
print()
byte_exp = [True & False, True | False, 
            1 & 0, 0 | 1, 1 | False, False | 1, 0 & True, True & 1, 
            ~ int(0), ~ 1, ~ False, ~ True] 
for be in byte_exp: print(be, end=' ')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# built-in /  incorporada => bool()
print(bool(None), not bool(None), not None, ~ bool(None))
print(*map(bool,(0, 0j, 1, -4., 2j)))
print(*map(bool,([1,2,3],{1,2,3})))
print(*map(bool,(list(),tuple(),[],set(),{})))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# str - string, sequential, immutable
# str - cadena, secuencial, inmutable
for el in [dir('abc')[i:i+6] for i in range(0,80,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# returned by the built-in constructor function str()
# devuelto por la funci√≥n constructora incorporada str()
print(*map(str,(*range(5), [1,2,3], *set(), {})), sep=' | ')
# result of some math operations
# resultado de algunas operaciones matem√°ticas
print(bin(25), type(bin(25)), hex(25), type(hex(25)), sep=' | ')
# is broken down into elements-symbols
# se descompone en elementos-s√≠mbolos
string = "123radar321"
print(list(string), tuple(string), set(string), sep='\n')
# slice(how much from start), slice(start, finish-1, step)
# segmento(cu√°nto desde el inicio), segmento(inicio, fin-1, paso)
print(string[slice(3)] == string[:3], 
      string[slice(1,5,2)] == string[1:5:2])
# palindrome / pal√≠ndromo
print(string == string[::-1])
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# a huge number of built-in methods
# much√≠simos m√©todos integrados
trans1 = {int(65):int(122),int(97):int(90),int(122):int(66),int(90):int(98)}
trans2 = {ord('A'):ord('z'),ord('a'):ord('Z'),
          ord('Z'):ord('b'),ord('z'):ord('B')}
s="AAAaaaZZZzzz"
s, s.translate(trans1), s.translate(trans2)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# join and repeat
# agregar y repetir
print(2 * 'abc ' + 3 * 'def' 'ghi ')
# match and belong
# coincidir y pertenecer
print('a' == 'abc','a' != 'abc','d' in 'abc','d' not in 'abc')
# with variables, not with literals
# con variables, no con literales
a, abc = 'a', 'abc'
print(a is abc,a is not abc)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# change the object / cambiar el objeto
# by generators / por generadores
string = "123rotor321"
gen = (x for x in string if not x.isdigit())
print(type(gen),''.join(gen))
# by anonymous function
# por funci√≥n an√≥nima
print(''.join(filter(lambda x: not x.isdigit(), string)))
# by regular expressions
# por expresiones regulares
import re
pattern = r'[0-9]'
print(re.sub(pattern,'',string), re.sub(pattern,'@',string,3),
      re.split('2',string), re.split('2',string,1))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# service characters can be ignored 
# caracteres de servicio se pueden ignorar 
print('abc\tdef', 'abc\\tdef', sep='<|!|>')
print('abc" "def', 'abc\' \'def', sep='<|!|>')
# r-strings / r-cuerdas 
# exclusion sequences are not translated
# secuencias de exclusi√≥n no est√°n traducidas
print(r'abc\tdef', R'abc\' \'def', sep='<|!|>')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
str_lst = ["oct: \150\145\154\154\157, hex: \x68\x65\x6c\x6c\x6f",
           r"oct: \147\145\154\154\157, hex: \x48\x65\x6c\x6c\x6f",
           '\u2192 \N{rightwards arrow}', r'\u2192 \N{rightwards arrow}',
           "hello \bhello", R"hello \bhello"]
for s in str_lst: print(s)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# check for identifiers and keywords
# comprobar identificadores y palabras clave
from keyword import iskeyword
str_lst = ['text', 'string', 'len', 'in']
for s in str_lst: print(s.isidentifier(), iskeyword(s))
# len can be an identifier
# len puede ser un identificador
len = len('123'); print(len)
del len
print(len)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# transitions to other types
# transiciones a otros tipos
bool(''), bool('a'), bool('1'), int('1'), float('1.1')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# different formatting styles
# diferentes estilos de formato
print("int: %d, oct: %o, hex: %x" % (3 * (65, )))
print('{:.2f}'.format(3.999))
from datetime import datetime
now = datetime.now().strftime("%b/%d/%Y - %H:%M:%S")
print(f'{now = } ; {now}')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# numeric / num√©rico: int, float, complex 
# ! in different number systems / en diferentes sistemas num√©ricos
for n in [1, 1., 1+1j]:
    for el in [dir(n)[i:i+6] for i in range(0, 72, 6)]:
        if el: print(el)
    print()
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# object attributes / atributos de objeto
x = 2 + 3j
print(x.real, x.imag, x.__class__)
print((2).__hash__(), (1024).__hash__(),
      (-2).__hash__(), (10 ** 12).__hash__())
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# the number of natural number digits is limited only 
# by the system you are using
# el n√∫mero de d√≠gitos de n√∫meros naturales est√° limitado √∫nicamente 
# por el sistema que est√°s utilizando
n = 10
str_num = n * '1234567890'
print(int(str_num) * n ** n)
del str_num
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# base is 10 by default, there are binary, octal, hexadecimal also
# la base es 10 por defecto, tambi√©n hay binario, octal y hexadecimal
print(int('11'), int('11',base=10),
      int('11',base=2), int('11',base=8), int('11',base=16))
# integer, binary, octal and hex literals
# literales enteros, binarios, octales y hexadecimales
numbers = [11, 0b11, 0B11, 0o11, 0O11, 0x11, 0X11]
for n in numbers:
    print('| ', n, '\t| ', (type(n)), end=' |\n')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# restrictions for real numbers
# the largest modulo values
# restricciones para n√∫meros reales
# los valores de m√≥dulo m√°s grandes
print(1.79e308, 1.799e308, 1.8e308, -1.8e308)
# values closest to zero
# valores m√°s cercanos a cero
print(1e-323, 8e-324, 7e-324, 5e-324, 3e-324, 2e-324, 1e-325)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# math operators / operadores matem√°ticos
print(+2, -2, 5 + 7, 4 - 1, 2 * 10, 2 ** 10, 9 / 5, 9 // 5, 9 % 5)
# built-in functions / funciones integradas
print(abs(-3), abs(-3 + 4j), round(1.1111, 2), pow(2, 10), divmod(9, 5))
print(5 * divmod(9, 5)[0] + divmod(9, 5)[1] == 9)
re, im = 3, -4
print(complex(re, im), re + im * 1j, complex(re, im) == re + im*1j)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# object methods / m√©todos de objeto
print(complex(3, 4).conjugate(), '\n',
      (35.41).hex(), float.fromhex('0x1.1b47ae147ae14p+5'))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# binary representation
number = int(-124)
print(bin(number), bin(number).lstrip('-0b'),
      number.bit_length(),-0b1111100)
# number of units in binary representation
print(number.bit_count()) # python 3.10 =>
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# bitwise representation / representaci√≥n bit a bit
(bin(4096).lstrip('-0b'), bin(4097).lstrip('-0b'),
 int(4096).to_bytes(2,byteorder='big'),
 int(4097).to_bytes(2,byteorder='big'), 
 int(1024).to_bytes(10,byteorder='big'),
 int(-1024).to_bytes(10,byteorder='big',signed=True),
 int(65).to_bytes(1,byteorder='little'),
 int(128).to_bytes(1,byteorder='little'))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# using modules: all known mathematical transformations
# usando m√≥dulos: todas las transformaciones matem√°ticas conocidas
import math
(math.cos(math.pi), 
 math.sin(math.degrees(math.pi/2)),
 math.degrees(math.pi/2), 
 math.sqrt(625), math.log(1), 
 math.ceil(-7.2), math.ceil(7.2))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# sequence types / tipos de secuencia 
# binary, string, list, tuple, range
# comparison / comparaci√≥n
print([1,2,"a",4.5,"b",5,6] == [1,2,5,"a",4.5,"b",6],
      [1,2,"a",4.5,"b",5,6] != [1,2,5,"a",4.5,"b",6],
      [1,2,"a",4.5,"b",5,6] is [1,2,5,"a",4.5,"b",6],
      [1,2,"a",4.5,"b",5,6] is not [1,2,5,"a",4.5,"b",6],
      tuple() == (), tuple(range(3)) == (i for i in range(3)))
print()
# inclusion / inclusi√≥n
print([2,3] in [1,2,3], [2,3] in (1,2,3),
      [2,3] in [1,[2,3]], [2,3] in (1,[2,3]),
      2 in range(3), [2] in range(3))
print()
# merge and repeat / fusionar y repetir
print((1,2,3) + (3,4,5), 3 * [1,2,3])
print()
# slices
r = range(3)
print(r[::-1], list(r)[::-1], tuple(r)[::-1])
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# all(), any()
l1 = [False,True,True,False]
l2 = [2,3,4,0,1,5]
t1 = (1,2,3,0)
t2 = ('a',5,2,'b')
print(all([]), all(l1), all(l2), any(l1), any(l2))
print(all(()), all(t1), all(t2), any(t1), any(t2))
print(range(0), list(range(0)),
      all(range(0)), all(list(range(0))),
      bool(range(0)), bool(list(range(0))))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# statistics / estadisticas
(len(range(3)), [1,2,3,1].count(1), 
 (1,2,3,1).index(1), min([1,2,3]), max(range(100)))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# small difference in syntax - big difference in properties
# peque√±a diferencia en sintaxis - gran diferencia en propiedades
type(tuple(range(3))), type((i for i in range(3)))
</script></div><br/><br/><br/>
    <table>
      <tr><th>the type "list"</th><th>el tipo "list"</th></tr>
      <tr><td>iterable</td><td>iterable</td></tr>
      <tr><td>collection (container)</td><td>colecci√≥n (contenedor)</td></tr>
      <tr><td>ordered</td><td>ordenado</td></tr>
      <tr><td>changeable</td><td>cambiable</td></tr>
      <tr><td>usually data of the same type</td><td>normalmente datos del mismo tipo</td></tr>
      <tr><td>repetitions of elements are possible</td><td>repeticiones de elementos son posibles</td></tr>
    </table><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# minimalist syntax / sintaxis minimalista
# empty list, enumeration, list expression
# lista vac√≠a, enumeraci√≥n, expresi√≥n de lista
print([], [1,2,3,4,5], [i for i in range(5)])
# result of the constructor / resultado del constructor
print(list(), list('abc'), list((i for i in range(3))))
# using an anonymous function or operators
# utilizando una funci√≥n u operadores an√≥nimos
print(list(map(lambda x:2*x**5-x**2+3, range(5))),
      list((*[1,2,3], *['a','b','c'])))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
for el in [dir([1,2,3])[i:i+6] for i in range(0,48,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# adding elements / adding elements
lst = [[]] * 3; print(lst)
lst[0].append(1); print(lst)
lst = [[]] * 3; print(lst)
lst[0].append(1); print(lst)
lst = 3 * [[]]; lst_copy = lst.copy()
print(lst, lst_copy)
lst_copy[0].append(1)
print(lst, lst_copy)
lst = [[]] + [[]] + [[]]; print(lst)
lst[0].append(1); print(lst)
# .append(<obj>), .extend(<iterable>)
lst = [[]]
lst.extend(2 * [[]]); print(lst)
lst[0].append(1); print(lst)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# using operators / usando operadores
lst = [1,2,3]; print(lst)
lst += [4]; print(lst)
lst *= 4; print(lst)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# element manipulations / manipulaciones con elementos
lst_zero = [0,0,0,0,0,0,0,0,0,0,0,0,0]
lst_zero.insert(1,333); print(lst_zero, '\n')
lst_zero[2:11:2] = [1,1,1,1,1]; print(lst_zero, '\n')
lst_zero[slice(3,10,2)] = [2,2,2,2]; print(lst_zero, '\n')
del(lst_zero[0:12:11]); print(lst_zero, '\n')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# object deleting / eliminaci√≥n de objetos
# deleting elements without deleting the list as a whole
# eliminar elementos sin eliminar la lista en su totalidad
lst = [1,2,3,4,5]; print(lst)
lst.clear(); print(lst, '\n') # del(lst[:])
# deleting by index / eliminar por √≠ndice
lst = [1,2,3,4,5]; print(lst)
lst.pop(); print(lst)
lst.pop(1); print(lst, '\n')
# deleting by value / eliminar por valor
lst = [1,2,3,4,5]; print(lst)
lst.remove(3); print(lst)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# changing the order of elements 
# cambiando el orden de los elementos
lst = [7,1,2,12,3,9,4,5]
print(lst[::-1], lst, '\n')
lst.reverse(); print(lst, '\n')
lst.sort(reverse=True); print(lst, '\n')
lst = sorted(lst); print(lst)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# indexing for nested lists / indexaci√≥n para listas anidadas
lst = ['1',['22',['333','444'],'55','66'],'7',['88','99'],'0']
print(lst[1][1][0], '333' in lst, 
      '333' in lst[1],'333' in lst[1][1])
</script></div><br/><br/><br/>
    <table>
      <tr><th>the type "tuple"</th><th>el tipo "tuple"</th></tr>
      <tr><td>iterable</td><td>iterable</td></tr>
      <tr><td>collection (container)</td><td>colecci√≥n (contenedor)</td></tr>
      <tr><td>ordered</td><td>ordenado</td></tr>
      <tr><td>immutable</td><td>inmutable</td></tr>
      <tr><td>usually data of different types</td><td>normalmente datos de diferentes tipos</td></tr>
      <tr><td>repetitions of elements are possible</td><td>repeticiones de elementos son posibles</td></tr>
    </table><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
for el in [dir((1,2,3))[i:i+6] for i in range(0,36,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# setup methods / m√©todos de configuraci√≥n
t0 = ()
t1 = 1,2,'a','b','c',3*('üçä','üçã','üçé','üçê','üçë')[1:3]
t2 = (True,1,2,3,'a')
t3 = tuple({True,1,2,3,'a'})
print(t0, t1, t2, t3, sep='\n')
print(type(t0) == type(t1) == type(t2) == type(t3))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# delete or entire object, 
# or just a fragment of the changeable element 
# eliminar o el objeto completo,
# o simplemente un fragmento del elemento cambiable
t = (True,[0,1,2,3],'a')
del(t[1][1]); print(t)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# concatenation of tuples or another type of object
# concatenaci√≥n de tuplas u otro tipo de objeto
([1,2,3],['a','b','c']), (*[1,2,3],*['a','b','c'])
</script></div><br/><br/><br/>
    <table>
      <tr><th>binary sequence types</th><th>tipos de secuencia binaria</th></tr>
      <tr><td>bytes: immutable, indexable</td><td>inmutable, indexable</td></tr>
      <tr><td>bytearray: mutable, indexable</td><td>mutable, indexable</td></tr>
      <tr><td>mutable, indexable</td><td></td></tr>
      <tr><td>memoryview:</td><td></td></tr>
      <tr><td> - accessing an object's internal data</td><td> - acceder a los datos internos de un objeto</td></tr>
      <tr><td> - with clipboard protocol </td><td> - con protocolo de portapapeles</td></tr>
      <tr><td> - without copying </td><td> - sin copiar</td></tr>
    </table><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# built-in constructor function bytes(),
# "b" | "B" | "br" | "Br" | bR | "BR" literals
# or coding in various systems
(bytes([1,2,3,128]), bytes.fromhex('f4'),
 'el ni√±o come camar√≥n'.encode(), '–ø—Ä–∏–≤–µ—Ç, –º–∏—Ä'.encode('cp855'))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# ASCII symbols & '\'
b'123', '123'.encode('ascii'), b'\\', '\\'.encode('ascii')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# reaction on built-in functions 
# reacci√≥n a las funciones integradas
ord(b'p'), ord('p'), chr(112), list(b'python')
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# detect those characters that are in unicode, but not in ascii
# detecta aquellos caracteres que est√°n en unicode, pero no en ascii
(b'el ni\xc3\xb1o come camar\xc3\xb3n'.decode(),
 b'\xd8\xe1\xb7\xeb\xa8\xe5, \xd2\xb7\xe1'.decode('cp855'))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# almost all built-in methods as for string literals
# casi todos los m√©todos integrados en cuanto a literales de cadena
# –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã
btrans = bytes.maketrans(b'abcde', b'12345')
string = 'machine learning'
print(string.translate(btrans))
f"{btrans}"
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# more examples / m√°s ejemplos
(b'1,2,3'.split(b','), b'abc'.replace(b'a',b'z'),
 b'%(language)s has %(number)03d binary sequence types'%\
 ({b'language': b'python', b'number': 3}))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# built-in constructor function / funci√≥n constructora incorporada 
(bytearray(), bytearray(5), bytearray(range(5)),
 bytearray(b'python'), bytearray(list(range(32,70))))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# difference from bytes / diferencia de bytes 
barr = bytearray("python bytearray","utf8")
print(barr)
# remove fragments / eliminando fragmentos
del barr[6:7]; print(barr)
# replacing elements / reemplazando elementos
barr[6:7] = b"|b"; print(barr)
# adding symbols / agregando s√≠mbolos
barr.append(38); print(barr)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# built-in memoryview() constructor function
# a way to modify big data without copying it
# funci√≥n constructora incorporada memoryView()
# una forma de modificar big data sin copiarlos
import time
n = 10**6
byarr = bytes(n)
mvarr = memoryview(byarr)
start = time.time()
while byarr:
    byarr = byarr[1:]
print(f"bytes: {time.time()-start:.3f}")
start = time.time()
while mvarr:
    mvarr = mvarr[1:]
print(f"memoryview: {time.time()-start:.3f}")
</script></div><br/><br/><br/>
    <table>
      <tr><th>set, frozenset</th><th>conjunto, conjunto congelado</th></tr>
      <tr><td>unordered</td><td>desordenado</td></tr>
      <tr><td>collection of hashable objects or hashable instance</td>
          <td>colecci√≥n de objetos hash o instancia hashable</td></tr>
      <tr><td>no repetition of elements</td><td>no hay repetici√≥n de elementos</td></tr>
      <tr><td>may contain data of different types</td><td>puede contener datos de diferentes tipos</td></tr>
      <tr><td>frozenset - immutable, set - mutable</td><td>frozenset - inmutable, set - mutable</td></tr>
    </table><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
for el in [dir({1,2,3})[i:i+6] for i in range(0,60,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
for el in [dir(frozenset((1,2,3)))[i:i+6] for i in range(0,48,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
(set(), frozenset(), set(range(5)), frozenset(range(5)),
 {14,3,9,'a',True}, set([1,2,9,7,4]), frozenset((1,2,9,7,4)))
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# remove elements / eliminar elementos
s01 = {14,3,9,'a',True,'bb'}; print(s01)
s01.pop(); print(s01)
s01.pop(); print(s01)
s01.remove(14); print(s01)
# no error even if there is no element
# no hay error incluso si no hay ning√∫n elemento
s01.discard(9); print(s01)
s01.discard(9); print(s01)
s01.clear(); print(s01)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# set manipulations / manipulaciones de conjuntos
s02 = {1,2,5,7,'a','dddd'}
s03 = s01.union(s02); print(s03)
s03 = s01 | s02; print(s03)
s04 = s01.intersection(s02); print(s04)
s04 = s01 & s02; print(s04)
s05 = s01.difference(s02); print(s05)
s05 = s01 - s02; print(s05)
s06 = s01.symmetric_difference(s02); print(s06)
# s06 = s01 ^ s02; print(s06) in python only
(s01.issubset(s03),s02.issubset(s04),
 s01 <= s03,s02 <= s04,
 s03.issuperset(s01),s04.issuperset(s02),
 s03 >= s01,s04 >= s02)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# add or copy elements / agregar o copiar elementos
s01 = {14,3,9,'a',True}
s01.add('bb'); print(s01)
s01 |= {'ccc'}; print(s01)
s01.update({4,8,3}); print(s01)
s01 |= {8,5,0}; print(s01)
s01.copy()
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# adding or removing elements is not possible
# no es posible agregar o eliminar elementos
s07 = frozenset({1,2,3,'a'})
s08 = frozenset({'a','b','c',3})
(s07.__hash__(), s08.__hash__(), 
 s07 | s08, s07 & s08)
</script></div><br/><br/><br/>
   <table>
      <tr><th>mapping types: dict</th><th>tipos de asignaci√≥n: dict</th></tr>
      <tr><td>projecting type (keys <-> values)</td><td>tipo de proyecci√≥n (llaves <-> valores)</td></tr>
      <tr><td>container</td><td>contenedor</td></tr>
      <tr><td>unordered object</td><td>objeto desordenado</td></tr>
      <tr><td>keys:</td><td>llaves:</td></tr>
      <tr><td> - only immutable types</td><td> - solo tipos inmutables</td></tr>
      <tr><td> - only unique (non-repeating) object</td><td> - s√≥lo objetos √∫nicos (no repetidos)</td></tr>
    </table><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
for el in [dir({1:1,2:2,3:3})[i:i+6] for i in range(0,48,6)]:
    print(el)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
xy = {1:11,2:22,3:33,4:44,5:55}
yx = dict(zip(xy.values(),xy.keys()))
z1 = dict([(1,'hola'),(2,'hello')])
z2 = dict([[1,'hola'],[2,'hello']])
dict(), {}, type({}), xy, yx, z1, z2, z1 == z2
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
(dict.fromkeys([1,2,3]),
 dict.fromkeys([1,2,3],[11,22,33]),
 dict.fromkeys((1,2,3),(11,22,33)),
 dict(zip([1,2,3],[11,22,33])),
 {i:i*11 for i in range(1,4)})
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# composition of objects / composici√≥n de objetos
z = {1:'a',2:'bb',3:'ccc',4:'dddd',5:'eeeee'}
z.keys(), z.values(), z.items(), z.get(1), z[1]
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# change objects / cambiar objetos
z = {1:'a',2:'bb'}; print(z)
z.update({3:'dddd',4:'ccc'}); print(z)
z[3] = 'ccc'; print(z)
z = {**z,**{4:'dddd'}}; print(z)
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">
# use built-in and anonymous functions
# utilizar funciones integradas y an√≥nimas
d = {1:111, 3:333, 5:555}
(len(d), list(d), 
 d[max(d.keys(),key=(lambda k: d[k]))])
</script></div><br/><br/><br/>
<div class="linked_sage"><script type="text/x-sage">

</script></div><br/><br/><br/>
  </body>
</html>
