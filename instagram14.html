<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Instagram_Posts14</title>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>$(function (){
    sagecell.makeSagecell({inputLocation:'div.linked',linked:true,
                           evalButtonText:'Run Linked Cells'});
    sagecell.makeSagecell({inputLocation:'div.sage_html',evalButtonText:'Run HTML'});  
    sagecell.makeSagecell({inputLocation:'div.sage_js',evalButtonText:'Run JavaScript'});
    sagecell.makeSagecell({inputLocation:'div.sage_r',evalButtonText:'Run R'});  
    sagecell.makeSagecell({inputLocation:'div.sage',evalButtonText:'Run SageMath'}); });
    </script>
  </head>
  <style>
  @import url('https://fonts.googleapis.com/css?family=Orbitron');
  h1, h2 {color:#3636ff; font-family:'Orbitron'; text-shadow:5px 5px 5px #aaa;}
  p, a {color:darkblue; font-size:120%; text-shadow:5px 5px 5px #aaa;}
  .sagecell .CodeMirror-scroll {min-height:3em; max-height:60em;}
  body {margin:5px 5px 5px 15px;}
  </style>  
  <body>
    <h1>&#x1F4D1; &nbsp;Instagram Posts. Part 14</h1>
<a href="https://olgabelitskaya.github.io/README.html">&#x1F300; &nbsp; Home Page &nbsp; &nbsp;</a> 
<a href="https://olgabelitskaya.github.io/instagram13.html">&#x1F300; &nbsp; Previous &nbsp; &nbsp;</a><br/>
<a href="https://www.instagram.com/olga.belitskaya/">&#x1F300; &nbsp; Instagram Posts &nbsp; &nbsp;</a>     
<a href="https://www.pinterest.ru/olga_belitskaya/code-style/">&#x1F300; &nbsp; Pinterest Posts</a>
    <h1>If you want to experiment with one neuron</h1>
SageMath &#38; SageMathCell <br/>
<div class="sage"><script type="text/x-sage">
import numpy as np,pylab as pl
# functions for neuron construction
def sigmoid(x): return 1.0/(1+np.exp(-x))
def sigmoid_derivation(x): return x*(1.0-x)
# artificial data for the experiment
X=np.array([[.11,.05,.95],[.09,.03,.08],[.01,.09,.91],
            [.04,.92,.07],[.05,.02,.04],[.07,.97,.05],
            [.06,.02,.98],[.02,.06,.03],[.01,.09,.03],
            [.02,.94,.01],[.06,.03,.95],[.04,.91,.09]])
Y=np.array([[1,0,1,2,0,2,1,0,1,2,1,2]]).T
fig,ax=pl.subplots(nrows=2,ncols=1,figsize=(10,4))
ax[0].imshow(X.T,cmap=pl.cm.cool)
ax[0].set_xticks([])
ax[0].text(-.3,1,str(Y.T)[2:-2],color='white',fontsize=35)
ax[0].set_title('Real Labels with One Error')
# the start point for iterations
synapse0=np.random.randn(3,1); layer0=X
# the steps of iterations
for iter in range(100):
    layer1=sigmoid(np.dot(layer0,synapse0))
    # finding errors and directions for correction
    layer1_error=layer1-Y
    layer1_delta=layer1_error*sigmoid_derivation(layer1)
    # correction values & coefficients
    synapse0_derivative=np.dot(layer0.T,layer1_delta)
    synapse0-=synapse0_derivative
# comparing predictions and real data
# the error in the start labeling (the 9th image) had been corrected
def labeling(x):
    if (x<.7): return 0
    if (x>.7) and (x<.99): return 1
    else: return 2
predict_Y=np.array([[labeling(layer1[i,0]) for i in range(12)]]).T
ax[1].imshow(X.T,cmap=pl.cm.cool)
ax[1].set_xticks([])
ax[1].text(-.3,1,str(predict_Y.T)[2:-2],color='white',fontsize=35)
ax[1].set_title('Predicted Labels'); pl.show()
print(np.hstack((np.hstack((X,Y)),(layer1.round(3)),(predict_Y))))
</script></div><br/>
    <h1>If you want to experiment with PyTorch</h1>
SageMath &#38; SageMathCell <br/>
<div class="linked"><script type="text/x-sage">
!python3 -m pip install torch --user
spath='/home/sc_work/.sage/local/lib/python3.7/site-packages'
import sys; sys.path.append(spath)
import numpy as np,pandas as pd,pylab as pl,torch
from sklearn.datasets import make_classification
dev=torch.device("cuda:0" \
if torch.cuda.is_available() else "cpu")
class Perceptron():
    def __init__(self,num_features):
        self.num_features=num_features
        self.weights=torch.zeros(num_features,int(1), 
                                 dtype=torch.float32,device=dev)
        self.bias=torch.zeros(1,dtype=torch.float32,device=dev)
    def forward(self,x):
        values=torch.add(torch.mm(x,self.weights),self.bias)
        a=torch.ones(values.size()[0],int(1))
        b=torch.zeros(values.size()[0],int(1))
        predictions=torch.where(values>float(0.),a,b).float()
        return predictions        
    def backward(self,x,y):  
        predictions=self.forward(x)
        errors=y-predictions
        return errors        
    def train(self,x,y,epochs):
        for e in range(epochs):            
            for i in range(y.size()[0]):
                errors=self.backward(x[i].view(int(1),self.num_features),
                                     y[i]).view(-int(1))
                self.weights+=(errors*x[i]).view(self.num_features,int(1))
                self.bias+=errors                
    def acc(self,x,y):
        predictions=self.forward(x).view(-int(1))
        accuracy=torch.sum(predictions==y).float()/y.size()[0]
        return accuracy
</script></div><br/>
<div class="linked"><script type="text/x-sage">
N=500; n=int(.2*N)
X,y=make_classification(n_samples=N,n_features=2,
                        n_redundant=0,n_informative=2)
mu,std=np.mean(X,axis=0),np.std(X,axis=0)
X=(X-mu)/std
X,y=X.astype('float32'),y.astype('int32')
shuffle_ids=np.arange(N)
np.random.RandomState(23).shuffle(shuffle_ids)
X,y=X[shuffle_ids],y[shuffle_ids]
X_test,X_train=X[:n],X[n:]
y_test,y_train=y[:n],y[n:]
model=Perceptron(num_features=2)
tX_train=torch.tensor(X_train,dtype=torch.float32,
                      device=dev)
ty_train=torch.tensor(y_train,dtype=torch.float32,
                      device=dev)
model.train(tX_train,ty_train,epochs=int(5))
tX_test=torch.tensor(X_test,dtype=torch.float32,
                     device=dev)
ty_test=torch.tensor(y_test,dtype=torch.float32,
                     device=dev)
acc_test=model.acc(tX_test,ty_test)
print('Test accuracy: %.2f%%'%(acc_test*int(100)))
W,b=model.weights,model.bias
x_min=-int(2); x_max=int(2)
y_min=((-(W[int(0)]*x_min)-b[int(0)])/W[int(1)])
y_max=((-(W[int(0)]*x_max)-b[int(0)])/W[int(1)])
fig,ax=pl.subplots(1,2,sharex=True,figsize=(9,3))
ax[0].plot([x_min,x_max],[y_min,y_max],c='red')
ax[1].plot([x_min,x_max],[y_min,y_max],c='red')
ax[0].scatter(X_train[:,0],X_train[:,1],
              c=y_train,s=10,cmap=pl.cm.cool)
ax[1].scatter(X_test[:,0], X_test[:,1],
              c=y_test,s=10,cmap=pl.cm.cool)
ax[0].grid(); ax[1].grid(); pl.show()
</script></div><br/>
      <h1>_If you want to process h5 image files</h1>
SageMath &#38; Python <br/>
<div class="sage"><script type="text/x-sage">
import pandas as pd,numpy as np,pylab as pl
import zipfile,h5py,urllib
path='https://olgabelitskaya.github.io/'
zf='HrseBreedImages.h5.zip'
input_file=urllib.request.urlopen(path+zf)
output_file=open(zf,'wb'); 
output_file.write(input_file.read())
output_file.close(); input_file.close()
zipf=zipfile.ZipFile(zf,'r')
zipf.extractall(''); zipf.close()
f=h5py.File(zf[:-4],'r'); keys=list(f.keys())
images=np.array(f[keys[0]])
labels=np.array(f[keys[1]])
names=['Akhal-Teke','Appaloosa','Orlov Trotter',
       'Vladimir Heavy Draft','Percheron']
</script></div><br/>
SageMath &#38; Python <br/>
<div class="sage"><script type="text/x-sage">

</script></div><br/>
SageMath &#38; R <br/>
<div class="sage_r"><script type="text/x-sage">
%%r

</script></div><br/>
      <h1>____</h1>
HTML &#38; JavaScript &#38; SageMathCell (Click “Run HTML” twice!)<br/>
<div class="sage_html"><script type="text/x-sage">
%%html

</script></div><br/>
HTML &#38; JavaScript &#38; SageMathCell (Click “Run HTML” twice!)<br/>
<div class="sage_html"><script type="text/x-sage">
%%html

</script></div><br/>
  </body>
</html>