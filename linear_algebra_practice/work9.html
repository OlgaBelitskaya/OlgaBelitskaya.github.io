<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>LinearAlgebraWork9</title>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>$(function (){
    sagecell.makeSagecell({inputLocation:'div.linked_sage',linked:true,evalButtonText:'Run Linked Sage Cells'});
    sagecell.makeSagecell({inputLocation:'div.linked_python',linked:true,evalButtonText:'Run Linked Python Cells'});
    sagecell.makeSagecell({inputLocation:'div.linked_r',linked:true,evalButtonText:'Run Linked R Cells'});
    sagecell.makeSagecell({inputLocation:'div.sage',evalButtonText:'Run'});
    sagecell.makeSagecell({inputLocation:'div.sage_html',evalButtonText:'Run HTML'});});
    </script>
    <script data-ad-client="ca-pub-9200929962680356" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>
  <style>
  @import url('https://fonts.googleapis.com/css?family=Orbitron');
  h1, h2 {color:#3636ff; font-family:'Orbitron'; text-shadow:5px 5px 5px #aaa;}
  p, a {color:darkblue; font-size:110%; text-shadow:5px 5px 5px #aaa;}
  .sagecell .CodeMirror-scroll {min-height:3em; max-height:68em;}
  body {margin:5px 5px 5px 25px}
  </style>  
  <body>
    <h1>&#x1F4D1; &nbsp; Линейная алгебра. Практическая работа №9</h1>
    <h1>Плоскости</h1>
    <h2>1. Уравнения</h2>
Общий вид
<p>$\pi: \ a * x + b * y + c * z + d = 0$</p>
<p>$\overrightarrow{n}\{a;b;c\} \perp \pi$</p>
Проходящая через точку $A_0(x_0;y_0;z_0)$ и перпендикулярная $\overrightarrow{n}\{a;b;c\}$
<p>$\pi: \ a * (x - x_0) + b * (y - y_0) + c * (z -z_0) = 0$</p>
Через три точки $A_1 (x_1;y_1;z_1), A_2 (x_2,y_2,z_2), A_3 (x_3,y_3,z_3)$
<p>$\begin {vmatrix} x - x_1 & y - y_1 & z - z_1 \\ 
    x_2 - x_1 & y_2 - y_1 & z_2 - z_1 \\ x_3 - x_1 & y_3 - y_1 & z_3 - z_1 \end{vmatrix} = 0$</p>
В отрезках
<p>$\pi: \frac{x}{\alpha} + \frac{x}{\beta} + \frac{z}{\gamma} = 1$</p>
<p>$\alpha = -\frac{d}{a}, \ \beta = -\frac{d}{b}, \ \gamma = -\frac{d}{c}$</p>
Параметрические уравнения плоскости
<p>$\pi: \begin {cases} x = x_0 + p_1 * t_1 + p_2 * t_2 \\ 
    y = y_0 + q_1 * t_1 + q_2 * t_2 \\ 
    z = z_0 + r_1 * t_1 + r_2 * t_2 \end {cases}, \ t_1, t_2 \in \mathbb{R}$</p>
<p>$\overrightarrow{s_1}\{p_1;q_1;r_1\}, \ \overrightarrow{s_2}\{p_2;q_2;r_2\} 
    \parallel \pi, \ A_0(x_0;y_0;z_0) \in \pi$</p>
Нормальное уравнение плоскости
$P$ - проекция начала координат $O(0;0;0)$ на плоскость $\pi$
<p>$ |\overrightarrow{OP}| = p, \ \angle(\overrightarrow{OP}, 
    \overrightarrow{OX}) = \alpha, \ \angle(\overrightarrow{OP}, 
    \overrightarrow{OY}) = \beta, \ \angle(\overrightarrow{OP}, 
    \overrightarrow{OZ}) = \gamma, \ $</p>
<p>$\pi: x \cdot \cos \alpha + y \cdot \cos \beta + z \cdot \cos \gamma = p$</p>
<p>$\cos^2 \alpha + \cos^2 \beta + \cos^2 \gamma = 1$</p>
    <p>Активируйте этот код перед использованием любых ячеек Linked Sage Cells</p>
<div class="linked_sage"><script type="text/x-sage">
var('x,y,z,x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3')
var('a,b,c,d,p1,q1,r1,p2,q2,r2,t1,t2')
eq=[a*x+b*y+c*z+d==0,
    a*(x-x0)+b*(y-y0)+c*(z-z0)==0,
    Matrix(SR,3,[x-x1,y-y1,z-z1,
                 x2-x1,y2-y1,z2-z1,
                 x3-x1,y3-y1,z3-z1]).det()==0,
    x==x0+p1*t1+p2*t2,
    y==y0+q1*t1+q2*t2,
    z==z0+r1*t1+r2*t2]
</script></div><br/>    
<div class="linked_sage"><script type="text/x-sage">
solutions=[solve([eq[0],a==3,b==-1,c==-1,d==2],
                 a,b,c,d,x,y,z),
           solve([eq[1],a==3,b==2,c==-1,x0==1,y0==-1,z0==2],
                 a,b,c,d,x0,y0,z0,x,y,z),
           solve([eq[2],x1==-3,y1==2,z1==1,
                  x2==1,y2==-3,z2==3,x3==-2,y3==1,z3==1],
                 x1,y1,z1,x2,y2,z2,x3,y3,z3,x,y,z),
           solve([eq[3],eq[4],eq[5],x0==-1,y0==2,z0==-2,
                  p1==2,q1==1,r1==-1,p2==-2,q2==-3,r2==2],
                 x0,y0,z0,p1,q1,r1,p2,q2,r2,t1,t2,x,y,z)]
zsolutions=[solve([eq[0],a==3,b==-1,c==-1,d==2],a,b,c,d,z),
           solve([eq[1],a==3,b==2,c==-1,
                  x0==1,y0==-1,z0==2],a,b,c,d,x0,y0,z0,z),
           solve([eq[2],x1==-3,y1==2,z1==1,
                  x2==1,y2==-3,z2==3,x3==-2,y3==1,z3==1],
                 x1,y1,z1,x2,y2,z2,x3,y3,z3,z),
           solve([eq[3],eq[4],eq[5],x0==-1,y0==2,z0==-2,
                  p1==2,q1==1,r1==-1,p2==-2,q2==-3,r2==2],
                 x0,y0,z0,p1,q1,r1,p2,q2,r2,t1,t2,z)]
solutions[1],zsolutions[1]
</script></div><br/>
<div class="linked_sage"><script type="text/x-sage">
var('x,y,z'); s=(-2,2) 
f=[3*x-y-z+2,3*x+2*y-z+1,-2*x-2*y-z-1] 
colors=['#3636ff','#ff3636','#36ff36']
text_xyz=[(2,2,2),(-2,2,2),(-2,-1,2)] 
labels=['3x-y-z+2=0',
        '3x+2y-z+1=0',
        '-2x-2y-z-1=0']
p=sum([implicit_plot3d(f[i],s,s,s,
                       color=colors[i],
                       plot_points=10,
                       opacity=0.5,mesh=True) 
       for i in [0..2]])
t=sum([text3d(labels[i],text_xyz[i],
              color=colors[i]) 
       for i in [0..2]])
(p+t).show()
</script></div>
    <p>Активируйте этот код перед использованием любых ячеек Linked Python Cells</p>
<div class="linked_python"><script type="text/x-sage">
import numpy,sympy,pylab,matplotlib,warnings
from mpl_toolkits.mplot3d import Axes3D
warnings.simplefilter("ignore",category=RuntimeWarning)
X=numpy.linspace(start=-10,stop=10,num=50)
X,Y=numpy.meshgrid(X,X)
def plane1(a,b,c,d,x,y): return -(a*x+b*y+d)/c
def plane2(a,b,c,x0,y0,z0,x,y): 
    return -(a*(x-x0)+b*(y-y0))/c+z0
def plane3(x1,y1,z1,x2,y2,z2,x3,y3,z3,x,y):
    detX=(y2-y1)*(z3-z1)-(y3-y1)*(z2-z1)
    detY=(x2-x1)*(z3-z1)-(x3-x1)*(z2-z1)
    detZ=(x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)
    return z1-((x-x1)*detX-(y-y1)*detY)/detZ
Z=[plane1(3,-1,-1,2,X,Y),
   plane2(3,2,-1,1,-1,2,X,Y),
   plane3(-3,2,1,1,-3,3,-2,1,1,X,Y)]
for z in Z: 
    z[z<-10]=numpy.NaN; z[z>10]=numpy.NaN
x,y,z,x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3=\
sympy.symbols('x,y,z,x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3')
a,b,c,d,p1,q1,r1,p2,q2,r2,t1,t2=\
sympy.symbols('a,b,c,d,p1,q1,r1,p2,q2,r2,t1,t2')
eq=[a*x+b*y+c*z+d,
    a*(x-x0)+b*(y-y0)+c*(z-z0),
    sympy.Matrix([[x-x1,y-y1,z-z1],
                  [x2-x1,y2-y1,z2-z1],
                  [x3-x1,y3-y1,z3-z1]]).det(),
    x-x0-p1*t1-p2*t2,
    y-y0-q1*t1-q2*t2,
    z-z0-r1*t1-r2*t2]
</script></div><br/>
<div class="linked_python"><script type="text/x-sage">
solutions=[sympy.solve([eq[0],a-3,b+1,c+1,d-2],a,b,c,d,z),
           sympy.solve([eq[1],a-3,b-2,c+1,x0-1,y0+1,z0-2],
                       a,b,c,x0,y0,z0,z),
           sympy.solve([eq[2],x1+3,y1-2,z1-1,
                        x2-1,y2+3,z2-3,x3+2,y3-1,z3-1],
                       x1,y1,z1,x2,y2,z2,x3,y3,z3,z),
           sympy.solve([eq[3],eq[4],eq[5],x0+1,y0-2,z0+2,
                        p1-2,q1-1,r1+1,p2+2,q2+3,r2-2],
                       x0,y0,z0,p1,q1,r1,p2,q2,r2,x,y,z)]
for s in solutions: sympy.pprint(s); print('\n')
</script></div><br/>
<div class="linked_python"><script type="text/x-sage">
f=pylab.figure(figsize=(7,7))
ax=f.add_subplot(111,projection='3d')
colors=['#3636ff','#ff3636','#36ff36']
labels=['3x-y-z+2=0','3x+2y-z+1=0','-2x-2y-z-1=0']
for i in range(3): 
    ax.plot_surface(X,Y,Z[i],color=colors[i],alpha=0.5)
fake2Dlines=[matplotlib.lines.Line2D([0],[0],linestyle="none",
                                     c=colors[i],marker='d') 
             for i in range(3)]
ax.set_xlim(-10,10); ax.set_ylim(-10,10); ax.set_zlim(-10,10)
ax.legend(fake2Dlines,labels,loc=9); pylab.show()
</script></div>
    <p>Активируйте этот код перед использованием любых ячеек Linked R Cells</p>
<div class="linked_r"><script type="text/x-sage">
%%r
X<-Y<-seq(from=-10,to=11,by=1)
plane1<-function(a,b,c,d,x,y){-(a*x+b*y+d)/c}
plane2<-function(a,b,c,x0,y0,z0,x,y){-(a*(x-x0)+b*(y-y0))/c+z0}
plane3<-function(x1,y1,z1,x2,y2,z2,x3,y3,z3,x,y){
    detX<-(y2-y1)*(z3-z1)-(y3-y1)*(z2-z1)
    detY<-(x2-x1)*(z3-z1)-(x3-x1)*(z2-z1)
    detZ<-(x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)    
    z1-((x-x1)*detX-(y-y1)*detY)/detZ}
Z1<-plane1(3,-1,-1,2,X,Y)
Z2<-plane2(3,2,-1,1,-1,2,X,Y)
Z3<-plane3(-3,2,1,1,-3,3,-2,1,1,X,Y)
library(grDevices); library(Matrix)
</script></div><br/>
<div class="linked_r"><script type="text/x-sage">
%%r
svg(filename="Rplots.svg",width=7,height=7,pointsize=12,
    onefile=TRUE,family="sans",bg="white",
    antialias=c("default","none","gray","subpixel"))
cols<-c('#3636ff','#ff3636','#36ff36')
labs<-c('3x-y-z+2=0','3x+2y-z+1=0','-2x-2y-z-1=0')
plot(X,Z1,col=cols[1],type='l',lwd=3,
     xlim=c(-10,10),ylim=c(-10,10),xlab='x',ylab='z')
lines(X,Z2,col=cols[2],lwd=3)
lines(X,Z3,col=cols[3],lwd=3)
legend(4,-4,title='XOZ: y=0',labs,col=cols,lwd=3)
grid(); dev.off()
</script></div>
    <h2>2. Взаимное расположение точек, прямых и плоскостей</h2> 
Расстояние от точки $M(x_M;y_M;z_M)$ до плоскости $\pi: \ a * x + b * y + c * z + d = 0$
<p>$\rho(M, \pi) = \frac{|a * x_M + b * y_M + c * z_M + d|}{\sqrt{a^2 + b^2 + c^2}}$</p>
Две плоскости 
<p>$\pi_1: \ a_1 * x + b_1 * y + c_1 * z + d_1 = 0$, $\pi_2: \ a_2 * x + b_2 * y + c_2 * z + d_2 = 0$</p>
<p>$\pi_1 \equiv \pi_2 : \frac{a_1}{a_2} = \frac{b_1}{b_2} = \frac{c_1}{c_2} = \frac{d_1}{d_2}$</p>
<p>$\pi_1 \parallel \pi_2 : \frac{a_1}{a_2} = \frac{b_1}{b_2} = \frac{c_1}{c_2} \neq \frac{d_1}{d_2}$</p>
Расстояние между параллельными плоскостями
<p>$\rho(\pi_1, \pi_2) = \frac{|d_1 - d_2|}{\sqrt{a_1^2 + b_1^2 + c_1^2}} = 
    \frac{|d_1 - d_2|}{\sqrt{a_2^2 + b_2^2 + c_2^2}}$</p>
<p>$\pi_1 \cap \pi_2 : \frac{a_1}{a_2} \neq \frac{b_1}{b_2} \lor \frac{b_1}{b_2} \neq \frac{c_1}{c_2}$</p>
<p>$\pi_1 \perp \pi_2 : a_1*a_2 + b_1*b_2 + c_1*c_2 = 0$</p>
Угол между пересекающимися плоскостями
<p>$\cos \angle (\pi_1, \pi_2) : \frac{| a_1*a_2 + b_1*b_2 + c_1*c_2 |}
    {\sqrt{a_1^2 + b_1^2 + c_1^2} * \sqrt{a_2^2 + b_2^2 + c_2^2}}$</p>
Прямая $l : \frac{x - x_0}{p} = \frac{y - y_0}{q} = \frac{z - z_0}{r}$ 
      и плоскость $\pi: \ a * x + b * y + c * z + d = 0$
<p>$A_0(x_0;y_0;z_0) \in l, \ \overrightarrow{s}\{p;q;r\} 
    \parallel l, \ \overrightarrow{n}\{a;b;c\} \perp \pi$</p>
<p>$1. l \in \pi : a * x_0 + b * y_0 + c * z_0 + d = 0 \land a*p + b*q + c*r = 0$</p>
<p>$2. l \parallel \pi : a * x_0 + b * y_0 + c * z_0 + d \neq 0 \land a*p + b*q + c*r = 0$</p>
Расстояние между плоскостью и параллельной ей прямой:
<p>$\rho(l, \pi) = \rho(A_0, \pi) = \frac{|a * x_0 + b * y_0 + c * z_0 + d|}{\sqrt{a^2 + b^2 + c^2}}$</p>
<p>$3. l \cap \pi : a*p + b*q + c*r \neq 0; \ l \perp \pi : \frac{a}{p} = \frac{b}{q} = \frac{c}{r}$</p>
Угол между плоскостью и пересекающей ее прямой:
<p>$\sin \angle (l, \pi) : \frac{| a*p + b*q + c*r |}{\sqrt{a^2 + b^2 + c^2} * \sqrt{p^2 + q^2 + r^2}}$</p>    
Пример типового расчета<br/>
<div class="sage_html"><script type="text/x-sage">
%%html
<p style="color:slategray;">
$\mathscr{A(1;1;3),\;B(1;2;2),\;C(7;3;1)\in\pi\\
O(x_0;y_0;z_0):O\in\pi,\;AO=BO=CO=R\\
(x_0;y_0;z_0),\;R-?}$</p>
</script></div>
Решение с уравнениями второго порядка<br/>
<div class="linked_sage"><script type="text/x-sage">
var('x0,y0,z0')
x1,y1,z1,x2,y2,z2,x3,y3,z3=1,1,3,-1,2,2,7,-3,1
eq=[Matrix(SR,3,[x0-x1,y0-y1,z0-z1,
                 x2-x1,y2-y1,z2-z1,
                 x3-x1,y3-y1,z3-z1]).det()==0,
    (x0-x1)^2+(y0-y1)^2+(z0-z1)^2==\
    (x0-x2)^2+(y0-y2)^2+(z0-z2)^2,
    (x0-x3)^2+(y0-y3)^2+(z0-z3)^2==\
    (x0-x2)^2+(y0-y2)^2+(z0-z2)^2]
O=solve(eq,x0,y0,z0)
x0,y0,z0=O[0][0].rhs(),O[0][1].rhs(),O[0][2].rhs()
R=sqrt((x0-x1)^2+(y0-y1)^2+(z0-z1)^2); x0,y0,z0,R
</script></div><br/>
<div class="linked_python"><script type="text/x-sage">
import sympy
x0,y0,z0=sympy.symbols('x0,y0,z0')
x1,y1,z1,x2,y2,z2,x3,y3,z3=1,1,3,-1,2,2,7,-3,1
eq=[sympy.Matrix([[x0-x1,y0-y1,z0-z1],
                  [x2-x1,y2-y1,z2-z1],
                  [x3-x1,y3-y1,z3-z1]]).det(),
    (x0-x1)**2+(y0-y1)**2+(z0-z1)**2-\
    (x0-x2)**2-(y0-y2)**2-(z0-z2)**2,
    (x0-x3)**2+(y0-y3)**2+(z0-z3)**2-\
    (x0-x2)**2-(y0-y2)**2-(z0-z2)**2]
O=sympy.solve(eq,x0,y0,z0)
x0,y0,z0=O[x0],O[y0],O[z0]
R=sympy.sqrt((x0-x1)**2+(y0-y1)**2+(z0-z1)**2)
x0,y0,z0,R
</script></div>
Решение с уравнениями первого порядка
<p>$\pi : A,B,C \in \pi$</p> 
<p>$\pi : \\ (x-x_A)[(y_B-y_A)(z_C-z_A)-(y_C-y_A)(z_B-z_A)]- \\ 
    -(y-y_A)[(x_B-x_A)(z_C-z_A)-(x_C-x_A)(z_B-z_A)]+ \\ 
    +(z-z_A)[(x_B-x_A)(y_C-y_A)-(x_C-x_A)(y_B-y_A)] = 0$</p> 
<p>$D: AD=BD \implies D(\frac{x_A+x_B}{2};\frac{y_A+y_B}{2};\frac{z_A+z_B}{2})$</p> 
<p>$E: AE=CE \implies E(\frac{x_A+x_C}{2};\frac{y_A+y_C}{2};\frac{z_A+z_C}{2})$</p> 
<p>$\overrightarrow{AB}\{x_B-x_A;y_B-y_A;z_B-z_A\},\ 
    \overrightarrow{AC}\{x_C-x_A;y_C-y_A;z_C-z_A\}$</p> 
<p>$\pi_1 : \overrightarrow{AB} \perp \pi_1, D \in \pi_1$</p> 
<p>$\pi_1 : (x_B-x_A)*(x-\frac{x_A+x_B}{2})+
            (y_B-y_A)*(y-\frac{y_A+y_B}{2})+
            (z_B-z_A)*(z-\frac{z_A+z_B}{2})=0$</p> 
<p>$\pi_2 : \overrightarrow{AC} \perp \pi_2, E \in \pi_2$</p> 
<p>$\pi_2 : (x_C-x_A)*(x-\frac{x_A+x_C}{2})+
            (y_C-y_A)*(y-\frac{y_A+y_C}{2})+
            (z_C-z_A)*(z-\frac{z_A+z_C}{2})=0$</p> 
<p>$O \in \pi, \pi_1, \pi_2$</p>
<div class="linked_python"><script type="text/x-sage">
import numpy
xA,yA,zA,xB,yB,zB,xC,yC,zC=1,1,3,-1,2,2,7,-3,1
# π
a1=numpy.array([(yB-yA)*(zC-zA)-(yC-yA)*(zB-zA),
                -(xB-xA)*(zC-zA)+(xC-xA)*(zB-zA),
                (xB-xA)*(yC-yA)-(xC-xA)*(yB-yA)])
b1=sum(numpy.array([xA,yA,zA])*a1)
# π1
a2=numpy.array([xB-xA,yB-yA,zB-zA])
b2=sum(numpy.array([(xA+xB)/2,(yA+yB)/2,(zA+zB)/2])*a2)
# π2
a3=numpy.array([xC-xA,yC-yA,zC-zA])
b3=sum(numpy.array([(xA+xC)/2,(yA+yC)/2,(zA+zC)/2])*a3)
# O,R
a=numpy.array([a1,a2,a3]); b=numpy.array([b1,b2,b3]) 
[x0,y0,z0]=numpy.linalg.solve(a,b)
R=numpy.sqrt((x0-x1)**2+(y0-y1)**2+(z0-z1)**2)
print([x0,y0,z0]); print(R); print(a); print(b) 
</script></div><br/>
<div class="linked_r"><script type="text/x-sage">
%%r
xA<-1; yA<-1; zA<-3
xB<--1; yB<-2; zB<-2
xC<-7; yC<--3; zC<-1
# π
a1<-c((yB-yA)*(zC-zA)-(yC-yA)*(zB-zA),
      -(xB-xA)*(zC-zA)+(xC-xA)*(zB-zA),
      (xB-xA)*(yC-yA)-(xC-xA)*(yB-yA))
b1<-sum(c(xA,yA,zA)*a1)
# π1
a2<-c(xB-xA,yB-yA,zB-zA)
b2<-sum(c((xA+xB)/2,(yA+yB)/2,(zA+zB)/2)*a2)
# π2
a3<-c(xC-xA,yC-yA,zC-zA)
b3<-sum(c((xA+xC)/2,(yA+yC)/2,(zA+zC)/2)*a3)
# O,R
a<-matrix(c(a1,a2,a3),ncol=3,byrow=T)
b<-c(b1,b2,b3)
O<-solve(a,b); x0<-O[1]; y0<-O[2]; z0<-O[3]
R<-sqrt((x0-xA)^2+(y0-yA)^2+(z0-zA)^2)
print(c(O,R)); matrix(c(a,b),nrow=3)
</script></div> 
    <h2>3. Задание</h2>
Создать массив координат 4 точек так, чтобы они не принадлежали одной плоскости.<br/>
Составить уравнения в общем виде 2 плоскостей, <br/>
содержащих по крайней мере 3 точки из созданного массива, <br/>
используя SageMath, Numpy, SymPy или R.<br/> 
<div class="linked_sage"><script type="text/x-sage">

</script></div><br/>
<div class="linked_python"><script type="text/x-sage">

</script></div><br/>  
<div class="linked_r"><script type="text/x-sage">
%%r

</script></div>
    <h2>4. Отдельная ячейка для дополнительных экспериментов</h2>      
<div class="sage"><script type="text/x-sage">

</script></div>
  </body>
</html> 